"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const utils_1 = require("../lib/utils");
const path_1 = require("path");
const fs_1 = require("fs");
const utils_2 = require("../lib/utils");
const { writeFile } = fs_1.promises;
const maxJSCompiler_1 = require("../lib/maxJSCompiler");
const parseCLIPath = (input) => path_1.isAbsolute(input) ? input : path_1.normalize(path_1.join(process.cwd(), input));
class Build extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Build);
        let code = "";
        try {
            const compiler = new maxJSCompiler_1.MaxJSCompiler({ filepath: args.file });
            await compiler.setup();
            code = await compiler.output();
        }
        catch (err) {
            return void this.error(`Failed to compile JS Code: ${err.message}`, {
                code: err.code,
                exit: utils_1.ExitCodes.error
            });
        }
        if (!flags.output)
            return void process.stdout.write(code);
        if (fs_1.existsSync(flags.output)) {
            // not a file
            if (!(await utils_2.isFile(flags.output))) {
                return void this.error(`Output file ${flags.output} can't be overwritten as it doesn't seem to be a file.`, {
                    exit: utils_1.ExitCodes.no_file_overwrite
                });
            }
            // no force remove
            if (!flags.force) {
                return void this.error(`Output file ${flags.output} already exists. Please remove it or use the --force option.`, {
                    exit: utils_1.ExitCodes.no_overwrite
                });
            }
        }
        await utils_2.ensureDir(path_1.dirname(flags.output));
        await writeFile(flags.output, code, { encoding: "utf8", flag: "w" });
    }
}
Build.description = "Build and bundle a Project for usage within the [js] or the [jsui] object";
Build.examples = [];
Build.flags = {
    help: command_1.flags.help({ "char": "h" }),
    force: command_1.flags.boolean({
        "char": "f",
        description: "Force overwrite the output file",
        "default": false,
        hidden: false,
        required: false
    }),
    output: command_1.flags.string({
        "char": "o",
        description: "Output generated file",
        hidden: false,
        multiple: false,
        parse: parseCLIPath,
        required: false
    })
};
Build.args = [
    {
        name: "file",
        required: true,
        description: "InputFile",
        hidden: false,
        parse: parseCLIPath
    }
];
exports.default = Build;
